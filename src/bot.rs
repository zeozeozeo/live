#[cfg(not(feature = "geode"))]
use crate::hooks;

use crate::utils;
use anyhow::Result;
use egui::{
    emath, pos2, vec2, Align2, Color32, Direction, DragValue, Key, KeyboardShortcut, Modifiers,
    RichText,
};
use egui_keybind::{Bind, Keybind, Shortcut};
use egui_modal::{Icon, Modal};
use egui_toast::{Toast, ToastKind, ToastOptions, Toasts};
use kittyaudio::{Device, Mixer, PlaybackRate, Sound, SoundHandle, StreamSettings};
use once_cell::sync::Lazy;
use rand::{prelude::SliceRandom, Rng};
use rfd::FileDialog;
use serde::{Deserialize, Serialize};
use std::{
    ffi::c_void,
    ops::{Deref, DerefMut, RangeInclusive},
    path::{Path, PathBuf},
    process::Command,
    sync::{Arc, Mutex, Once},
    time::{Duration, Instant},
};
use windows::Win32::System::Console::{AllocConsole, FreeConsole};

/// Global bot state
pub static mut BOT: Lazy<Box<Bot>> = Lazy::new(Box::<Bot>::default);

pub mod built_info {
    // generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

pub enum PlayerButton {
    Push,
    Release,
    Left,
    Right,
}

impl PlayerButton {
    #[inline]
    pub const fn from_u8(b: u8) -> Option<Self> {
        match b {
            0 => Some(Self::Push),
            1 => Some(Self::Release),
            2 => Some(Self::Left),
            3 => Some(Self::Right),
            _ => None,
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Timings {
    pub hard: f32,
    pub regular: f32,
    pub soft: f32,
}

impl Default for Timings {
    fn default() -> Self {
        Self {
            hard: 2.0,
            regular: 0.15,
            soft: 0.025,
            // lower = microclicks
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Pitch {
    pub from: f64,
    pub to: f64,
    #[serde(default = "f64::default")]
    pub step: f64,
}

impl Default for Pitch {
    fn default() -> Self {
        Self {
            from: 0.95,
            to: 1.05,
            step: 0.001,
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct VolumeSettings {
    pub enabled: bool,
    pub spam_time: f32,
    pub spam_vol_offset_factor: f32,
    pub max_spam_vol_offset: f32,
    pub change_releases_volume: bool,
    pub global_volume: f32,
    pub volume_var: f32,
}

impl Default for VolumeSettings {
    fn default() -> Self {
        Self {
            enabled: true,
            spam_time: 0.3,
            spam_vol_offset_factor: 0.9,
            max_spam_vol_offset: 0.3,
            change_releases_volume: false,
            global_volume: 1.0,
            volume_var: 0.2,
        }
    }
}

#[derive(Default, Clone, Copy, Debug, PartialEq)]
pub enum ClickType {
    HardClick,
    HardRelease,
    Click,
    Release,
    SoftClick,
    SoftRelease,
    MicroClick,
    MicroRelease,
    #[default]
    None,
}

impl ClickType {
    pub fn from_time(push: bool, time: f32, timings: &Timings) -> Self {
        if time > timings.hard {
            if push {
                Self::HardClick
            } else {
                Self::HardRelease
            }
        } else if time > timings.regular {
            if push {
                Self::Click
            } else {
                Self::Release
            }
        } else if time > timings.soft {
            if push {
                Self::SoftClick
            } else {
                Self::SoftRelease
            }
        } else if push {
            Self::MicroClick
        } else {
            Self::MicroRelease
        }
    }
    pub fn preferred(self) -> [Self; 8] {
        use ClickType::*;

        // HardClick => HardClick, Click, SoftClick, MicroClick, HardRelease, Release, SoftRelease, MicroRelease
        // HardRelease => HardRelease, Release, SoftRelease, MicroRelease, HardClick, Click, SoftClick, MicroClick
        // Click => Click, HardClick, SoftClick, MicroClick, Release, HardRelease, SoftRelease, MicroRelease
        // Release => Release, HardRelease, SoftRelease, MicroRelease, Click, HardClick, SoftClick, MicroClick
        // SoftClick => SoftClick, MicroClick, Click, HardClick, SoftRelease, MicroRelease, Release, HardRelease
        // SoftRelease => SoftRelease, MicroRelease, Release, HardRelease, SoftClick, MicroClick, Click, HardClick
        // MicroClick => MicroClick, SoftClick, Click, HardClick, MicroRelease, SoftRelease, Release, HardRelease
        // MicroRelease => MicroRelease, SoftRelease, Release, HardRelease, MicroClick, SoftClick, Click, HardClick

        match self {
            HardClick => [
                HardClick,
                Click,
                SoftClick,
                MicroClick,
                HardRelease,
                Release,
                SoftRelease,
                MicroRelease,
            ],
            HardRelease => [
                HardRelease,
                Release,
                SoftRelease,
                MicroRelease,
                HardClick,
                Click,
                SoftClick,
                MicroClick,
            ],
            Click => [
                Click,
                HardClick,
                SoftClick,
                MicroClick,
                Release,
                HardRelease,
                SoftRelease,
                MicroRelease,
            ],
            Release => [
                Release,
                HardRelease,
                SoftRelease,
                MicroRelease,
                Click,
                HardClick,
                SoftClick,
                MicroClick,
            ],
            SoftClick => [
                SoftClick,
                MicroClick,
                Click,
                HardClick,
                SoftRelease,
                MicroRelease,
                Release,
                HardRelease,
            ],
            SoftRelease => [
                SoftRelease,
                MicroRelease,
                Release,
                HardRelease,
                SoftClick,
                MicroClick,
                Click,
                HardClick,
            ],
            MicroClick => [
                MicroClick,
                SoftClick,
                Click,
                HardClick,
                MicroRelease,
                SoftRelease,
                Release,
                HardRelease,
            ],
            MicroRelease => [
                MicroRelease,
                SoftRelease,
                Release,
                HardRelease,
                MicroClick,
                SoftClick,
                Click,
                HardClick,
            ],
            None => [None, None, None, None, None, None, None, None],
        }
    }

    #[inline]
    pub const fn is_release(self) -> bool {
        matches!(
            self,
            ClickType::HardRelease
                | ClickType::Release
                | ClickType::SoftRelease
                | ClickType::MicroRelease
        )
    }
}

#[derive(Clone)]
pub struct SoundWrapper {
    sound: Sound,
    pathbuf: PathBuf,
    // fmod_sound: *mut FMOD_SOUND,
}

impl SoundWrapper {
    pub fn from_path(path: &Path) -> Result<Self> {
        // load kittyaudio sound
        let sound = Sound::from_path(path)?;
        Ok(Self {
            sound,
            pathbuf: path.to_path_buf(),
        })
    }

    fn free(&mut self) {
        // let _ = unsafe {
        //     FMOD_Sound_Release(self.fmod_sound)
        //         .fmod_result()
        //         .map_err(|e| log::error!("failed to release fmod sound: {e}"))
        // };
        // self.fmod_sound = std::ptr::null_mut();
    }
}

impl Deref for SoundWrapper {
    type Target = Sound;

    fn deref(&self) -> &Self::Target {
        &self.sound
    }
}

impl DerefMut for SoundWrapper {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.sound
    }
}

#[derive(Default)]
pub struct Sounds {
    pub hardclicks: Vec<SoundWrapper>,
    pub hardreleases: Vec<SoundWrapper>,
    pub clicks: Vec<SoundWrapper>,
    pub releases: Vec<SoundWrapper>,
    pub softclicks: Vec<SoundWrapper>,
    pub softreleases: Vec<SoundWrapper>,
    pub microclicks: Vec<SoundWrapper>,
    pub microreleases: Vec<SoundWrapper>,
    pub last_sound_path: PathBuf,
}

fn read_clicks_in_directory(dir: &Path) -> Vec<SoundWrapper> {
    let Ok(dir) = dir.read_dir() else {
        // log::warn!("can't find directory {dir:?}, skipping");
        return vec![];
    };
    let mut sounds = vec![];
    for entry in dir {
        let path = entry.unwrap().path();
        if path.is_file() {
            let sound = SoundWrapper::from_path(&path);
            if let Ok(sound) = sound {
                sounds.push(sound);
            } else if let Err(e) = sound {
                log::error!("failed to load '{path:?}': {e}");
            }
        }
    }
    sounds
}

pub fn find_noise_file(dir: &Path) -> Option<PathBuf> {
    let Ok(dir) = dir.read_dir() else {
        return None;
    };
    for entry in dir {
        let path = entry.unwrap().path();
        let filename = path.file_name().unwrap().to_str().unwrap();
        // if it's a noise*, etc file we should try to load it
        if path.is_file()
            && (filename.starts_with("noise")
                || filename.starts_with("whitenoise")
                || filename.starts_with("pcnoise")
                || filename.starts_with("background"))
        {
            return Some(path);
        }
    }
    None
}

impl Sounds {
    pub fn from_path(path: &Path) -> Self {
        let mut sounds = Self::default();

        for (dir, clicks) in [
            ("hardclicks", &mut sounds.hardclicks),
            ("hardreleases", &mut sounds.hardreleases),
            ("clicks", &mut sounds.clicks),
            ("releases", &mut sounds.releases),
            ("softclicks", &mut sounds.softclicks),
            ("softreleases", &mut sounds.softreleases),
            ("microclicks", &mut sounds.microclicks),
            ("microreleases", &mut sounds.microreleases),
        ] {
            let mut pathbuf = path.to_path_buf();
            pathbuf.push(dir);
            clicks.extend(read_clicks_in_directory(&pathbuf));
        }

        if !sounds.has_sounds() {
            log::warn!("no sounds found, assuming there's no subdirectories");
            sounds.clicks = read_clicks_in_directory(path);
        }

        sounds
    }

    #[inline]
    pub fn num_sounds(&self) -> usize {
        [
            &self.hardclicks,
            &self.hardreleases,
            &self.clicks,
            &self.releases,
            &self.softclicks,
            &self.softreleases,
            &self.microclicks,
            &self.microreleases,
        ]
        .iter()
        .map(|c| c.len())
        .sum()
    }

    fn free_fmod_sounds(&mut self) {
        for sounds in [
            &mut self.hardclicks,
            &mut self.hardreleases,
            &mut self.clicks,
            &mut self.releases,
            &mut self.softclicks,
            &mut self.softreleases,
            &mut self.microclicks,
            &mut self.microreleases,
        ] {
            for sound in sounds {
                sound.free();
            }
        }
    }

    #[inline]
    pub fn has_sounds(&self) -> bool {
        self.num_sounds() > 0
    }

    pub fn random_sound(&mut self, typ: ClickType) -> Option<(SoundWrapper, ClickType)> {
        let thread_rng = &mut rand::thread_rng();
        for typ in typ.preferred() {
            let sound = match typ {
                ClickType::HardClick => self.hardclicks.choose(thread_rng),
                ClickType::HardRelease => self.hardreleases.choose(thread_rng),
                ClickType::Click => self.clicks.choose(thread_rng),
                ClickType::Release => self.releases.choose(thread_rng),
                ClickType::SoftClick => self.softclicks.choose(thread_rng),
                ClickType::SoftRelease => self.softreleases.choose(thread_rng),
                ClickType::MicroClick => self.microclicks.choose(thread_rng),
                ClickType::MicroRelease => self.microreleases.choose(thread_rng),
                _ => None,
            };
            if let Some(sound) = sound {
                self.last_sound_path = sound.pathbuf.clone();
                return Some((sound.clone(), typ));
            }
        }
        None
    }

    pub fn extend_with(&mut self, other: &Self) {
        for (s, o) in [
            (&mut self.hardclicks, &other.hardclicks),
            (&mut self.hardreleases, &other.hardreleases),
            (&mut self.clicks, &other.clicks),
            (&mut self.releases, &other.releases),
            (&mut self.softclicks, &other.softclicks),
            (&mut self.softreleases, &other.softreleases),
            (&mut self.microclicks, &other.microclicks),
            (&mut self.microreleases, &other.microreleases),
        ] {
            s.extend_from_slice(o);
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Shortcuts {
    pub toggle_menu: Shortcut,
    pub toggle_bot: Shortcut,
    pub toggle_noise: Shortcut,
}

impl Default for Shortcuts {
    fn default() -> Self {
        Self {
            toggle_menu: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num1)),
                None,
            ),
            toggle_bot: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num2)),
                None,
            ),
            toggle_noise: Shortcut::NONE,
        }
    }
}

#[derive(Serialize, Deserialize, Default, Clone)]
pub enum Clickpack {
    #[default]
    None,
    Name(String),
    Path(PathBuf),
}

fn skip_serializing_selected_device(device: &str) -> bool {
    if cfg!(feature = "special") {
        let is_default = if let Ok(name) = Device::Default.name() {
            name == device
        } else {
            false
        };
        device.is_empty() || is_default
    } else {
        true
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Env {
    version: String,
    clickpack: Clickpack,
    #[serde(
        default = "String::new",
        skip_serializing_if = "skip_serializing_selected_device"
    )]
    pub selected_device: String,
}

impl Default for Env {
    fn default() -> Self {
        Self {
            version: built_info::PKG_VERSION.to_string(),
            clickpack: Clickpack::None,
            selected_device: String::new(),
        }
    }
}

impl Env {
    pub fn load() -> Self {
        let _ = std::fs::create_dir_all(".zcb")
            .map_err(|e| log::error!("failed to create .zcb directory: {e}"));

        let path = Path::new(".zcb/env.json");
        if let Ok(f) = std::fs::File::open(path) {
            let env = serde_json::from_reader(f);
            if let Ok(env) = env {
                return env;
            } else if let Err(e) = env {
                log::error!("failed to deserialize env: {e}");
            }
        }

        // if we're here we failed
        log::warn!("failed to deserialize env, writing defaults");
        if let Ok(f) = std::fs::File::create(path) {
            let _ = serde_json::to_writer_pretty(f, &Self::default())
                .map_err(|e| log::error!("failed to write env: {e}"));
        }

        Self::default()
    }

    pub fn save(&self) {
        log::info!("writing .zcb/env.json");
        let mut env = self.clone();
        env.version = built_info::PKG_VERSION.to_string();
        if let Ok(f) = std::fs::File::create(".zcb/env.json") {
            let _ = serde_json::to_writer_pretty(f, &env)
                .map_err(|e| log::error!("failed to write env: {e}"));
        }
    }

    pub fn update(&mut self, clickpack: Clickpack) {
        self.clickpack = clickpack;
        self.save();
    }
}

#[inline]
fn true_value() -> bool {
    true
}

#[inline]
fn default_buffer_size() -> u32 {
    512
}

#[inline]
fn float_one<Num: emath::Numeric>() -> Num {
    Num::from_f64(1.0)
}

// clickpack, options, audio
#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy)]
pub enum Stage {
    #[default]
    Clickpack,
    Audio,
    Options,
    Cheats,
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default)]
pub struct Cheats {
    pub noclip: bool,
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    pub pitch_enabled: bool,
    pub pitch: Pitch,
    pub timings: Timings,
    pub volume_settings: VolumeSettings,
    #[serde(default = "Shortcuts::default")]
    pub shortcuts: Shortcuts,
    #[serde(default = "true_value")]
    pub enabled: bool,
    #[serde(default = "bool::default")]
    pub hidden: bool,
    #[serde(default = "default_buffer_size")]
    pub buffer_size: u32,
    #[serde(default = "bool::default")]
    pub play_noise: bool,
    #[serde(default = "float_one")]
    pub noise_volume: f32,
    #[serde(default = "bool::default")]
    pub use_alternate_hook: bool,
    #[serde(default = "bool::default")]
    pub show_console: bool,
    #[serde(default = "Stage::default")]
    pub stage: Stage,
    #[serde(default = "bool::default")]
    pub use_fmod: bool,
    #[serde(default = "bool::default")]
    pub use_playlayer_time: bool,
    #[serde(default = "bool::default")]
    pub cut_sounds: bool,
    #[serde(default = "bool::default")]
    pub force_2player: bool,
    #[serde(default = "bool::default")]
    pub cut_by_releases: bool,
    #[serde(default = "float_one")]
    pub click_speedhack: f64,
    // #[serde(default = "true_value")]
    // pub sync_speed_with_game: bool,
    #[serde(default = "float_one")]
    pub noise_speedhack: f64,
    #[serde(default = "bool::default")]
    pub hook_wait: bool,
    #[serde(default = "bool::default")]
    pub use_minhook: bool,
    #[serde(default = "Cheats::default")]
    pub cheats: Cheats,
}

impl Config {
    #[inline]
    pub fn fixup(mut self) -> Self {
        self.buffer_size = self.buffer_size.max(1);
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            pitch_enabled: true,
            pitch: Pitch::default(),
            timings: Timings::default(),
            volume_settings: VolumeSettings::default(),
            shortcuts: Shortcuts::default(),
            enabled: true,
            hidden: false,
            buffer_size: default_buffer_size(),
            play_noise: false,
            noise_volume: 1.0,
            use_alternate_hook: false,
            show_console: false,
            stage: Stage::default(),
            use_fmod: false,
            use_playlayer_time: false,
            cut_sounds: false,
            force_2player: false,
            cut_by_releases: false,
            click_speedhack: 1.0,
            noise_speedhack: 1.0,
            // sync_speed_with_game: true,
            hook_wait: false,
            use_minhook: true,
            cheats: Cheats::default(),
        }
    }
}

impl Config {
    pub fn load() -> Result<Self> {
        let mut path = PathBuf::from(".zcb/");
        log::debug!("creating directory {path:?}");
        std::fs::create_dir_all(&path)?;
        path.push("config.json");

        // try to read config
        log::debug!("trying to read config at {path:?}");
        if let Ok(f) = std::fs::File::open(&path) {
            let config = serde_json::from_reader(f)
                .map_err(|e| log::error!("failed to deserialize config at {path:?}: {e}"));
            if let Ok(config) = config {
                log::debug!("successfully read config at {path:?}");
                return Ok(config);
            }
        }

        // failed to read config, write default config
        let config = Self::default();
        log::debug!("creating file {path:?}");
        let f = std::fs::File::create(&path)?;
        log::debug!("writing default config to {path:?}");
        serde_json::to_writer_pretty(f, &config)?;
        Ok(config)
    }

    pub fn save(&self) {
        let Ok(f) = std::fs::File::create(".zcb/config.json") else {
            log::error!("failed to create config.json!");
            return;
        };
        let _ = serde_json::to_writer_pretty(f, self)
            .map_err(|e| log::error!("failed to write config: {e}"))
            .map(|_| log::debug!("successfully saved config to \".zcb/config.json\""));
    }
}

pub struct Bot {
    pub conf: Config,
    pub players: (Sounds, Sounds),
    pub noise: Option<SoundWrapper>,
    pub mixer: Mixer,
    #[cfg(not(feature = "geode"))]
    pub playlayer: *mut c_void, // PlayLayer
    pub prev_time: f64,
    pub is_loading_clickpack: bool,
    pub num_sounds: (usize, usize),
    pub selected_clickpack: String,
    #[cfg(feature = "special")]
    pub devices: Arc<Mutex<Vec<String>>>,
    pub last_conf_save: Instant,
    pub prev_conf: Config,
    pub prev_click_type: ClickType,
    pub prev_resolved_click_type: ClickType,
    pub prev_pitch: f64,
    pub prev_volume: f32,
    pub prev_spam_offset: f32,
    pub buffer_size_changed: bool,
    pub noise_sound: Option<SoundHandle>,
    pub show_alternate_hook_warning: bool,
    pub did_reset_config: bool,
    pub clickpacks: Vec<PathBuf>,
    pub last_clickpack_reload: Instant,
    pub level_start: Instant,
    pub used_alternate_hook: bool,
    // pub system: *mut FMOD_SYSTEM,
    // pub channel: *mut FMOD_CHANNEL,
    pub env: Env,
    pub toast_queue: Arc<Mutex<Vec<Toast>>>,
    // pub fmod_noise_sound: *mut FMOD_CHANNEL,
    pub show_fmod_buffersize_warn: bool,
    pub startup_buffer_size: u32,
    pub used_minhook: bool,
    pub selected_clickpack_path: PathBuf,
    pub is_in_level: bool,
    pub playlayer_time: f64,
}

impl Default for Bot {
    fn default() -> Self {
        let conf = Config::load().unwrap_or_default().fixup();
        let used_alternate_hook = conf.use_alternate_hook;
        let startup_buffer_size = conf.buffer_size;
        let used_minhook = conf.use_minhook;
        Self {
            conf: conf.clone(),
            players: (Sounds::default(), Sounds::default()),
            noise: None,
            mixer: Mixer::new(),
            #[cfg(not(feature = "geode"))]
            playlayer: std::ptr::null_mut(), // PlayLayer::from_address(0)
            prev_time: 0.0,
            is_loading_clickpack: false,
            num_sounds: (0, 0),
            selected_clickpack: String::new(),
            #[cfg(feature = "special")]
            devices: Arc::new(Mutex::new(vec![])),
            last_conf_save: Instant::now(),
            prev_conf: conf,
            prev_click_type: ClickType::None,
            prev_resolved_click_type: ClickType::None,
            prev_pitch: f64::NAN,
            prev_volume: f32::NAN,
            prev_spam_offset: f32::NAN,
            buffer_size_changed: false,
            noise_sound: None,
            show_alternate_hook_warning: false,
            did_reset_config: false,
            clickpacks: vec![],
            last_clickpack_reload: Instant::now(),
            level_start: Instant::now(),
            used_alternate_hook,
            // system: std::ptr::null_mut(),
            // channel: std::ptr::null_mut(),
            env: Env::load(),
            toast_queue: Arc::new(Mutex::new(vec![])),
            // fmod_noise_sound: std::ptr::null_mut(),
            show_fmod_buffersize_warn: false,
            startup_buffer_size,
            used_minhook,
            selected_clickpack_path: PathBuf::new(),
            is_in_level: false,
            playlayer_time: 0.0,
        }
    }
}

const PLAYER_DIRNAMES: [(&str, &str, &str); 7] = [
    ("player1", "player2", "player3"),
    ("player 1", "player 2", "player 3"),
    ("sounds1", "sounds2", "sounds2"),
    ("sounds 1", "sounds 2", "sounds 3"),
    ("p1", "p2", "p3"),
    ("1", "2", "3"),
    ("", "", ""),
];

fn help_text<R>(ui: &mut egui::Ui, help: &str, add_contents: impl FnOnce(&mut egui::Ui) -> R) {
    if help.is_empty() {
        add_contents(ui); // don't show help icon if there's no help text
        return;
    }
    ui.horizontal(|ui| {
        add_contents(ui);
        ui.add_enabled_ui(false, |ui| ui.label("(?)").on_disabled_hover_text(help));
    });
}

/// Value is always min clamped with 1.
fn u32_edit_field_min1(ui: &mut egui::Ui, value: &mut u32) -> egui::Response {
    let mut tmp_value = format!("{value}");
    let res = ui.text_edit_singleline(&mut tmp_value);
    if let Ok(result) = tmp_value.parse::<u32>() {
        *value = result.max(1);
    }
    res
}

/*
#[inline]
fn gd_audio_pitch() -> f32 {
    let mut pitch = 1.0f32;
    unsafe {
        let _ = FMOD_Channel_GetPitch(
            FMODAudioEngine::shared().current_sound_channel(),
            &mut pitch,
        );
    };
    pitch
}
*/

fn drag_value<Num: emath::Numeric>(
    ui: &mut egui::Ui,
    value: &mut Num,
    text: impl Into<String>,
    clamp_range: RangeInclusive<Num>,
    help: &str,
) -> egui::Response {
    let mut resp = None;
    help_text(ui, help, |ui| {
        resp = Some(
            ui.add(
                DragValue::new(value)
                    .clamp_range(clamp_range.clone())
                    .speed(0.01),
            ),
        );
        ui.label(
            if resp.as_ref().unwrap().dragged()
                && (clamp_range.start() == value || clamp_range.end() == value)
            {
                RichText::new(text).color(Color32::LIGHT_RED)
            } else {
                RichText::new(text)
            },
        );
    });
    resp.unwrap()
}

impl Bot {
    fn unload_clickpack(&mut self) {
        log::debug!("unloading clickpack");
        self.num_sounds = (0, 0);
        self.players.0.free_fmod_sounds();
        self.players.1.free_fmod_sounds();
        if let Some(noise) = &mut self.noise {
            noise.free();
        }
        self.players = (Sounds::default(), Sounds::default());
        self.noise = None;
        if let Some(noise_sound) = self.noise_sound.take() {
            noise_sound.seek_to_end();
            noise_sound.set_loop_enabled(false);
            noise_sound.set_playback_rate(PlaybackRate::Factor(0.0));
        }
        self.selected_clickpack.clear();
        self.selected_clickpack_path.clear();
    }

    pub fn load_clickpack(&mut self, clickpack_dir: &Path) -> Result<()> {
        // reset current clickpack
        self.unload_clickpack();

        for player_dirnames in PLAYER_DIRNAMES {
            let mut player1_path = clickpack_dir.to_path_buf();
            player1_path.push(player_dirnames.0);
            let mut player2_path = clickpack_dir.to_path_buf();
            player2_path.push(player_dirnames.1);

            // load for both players
            self.players
                .0
                .extend_with(&Sounds::from_path(&player1_path /*self.system*/));
            self.load_noise(&player1_path);
            if !player_dirnames.1.is_empty() {
                self.players
                    .1
                    .extend_with(&Sounds::from_path(&player2_path /*self.system*/));
                self.load_noise(&player2_path);
            }
        }

        self.load_noise(clickpack_dir);

        anyhow::ensure!(self.has_sounds(), "no sounds found in clickpack");

        self.num_sounds = (self.players.0.num_sounds(), self.players.1.num_sounds());
        self.selected_clickpack = clickpack_dir
            .file_name()
            .unwrap()
            .to_str()
            .unwrap()
            .to_string();
        self.selected_clickpack_path = clickpack_dir.to_path_buf();
        log::info!(
            "loaded clickpack \"{}\", {} sounds",
            self.selected_clickpack,
            self.num_sounds.0 + self.num_sounds.1
        );
        log::info!("{} player 1 sounds", self.num_sounds.0);
        log::info!("{} player 2 sounds", self.num_sounds.1);
        log::info!("has noise: {}", self.noise.is_some());

        self.play_noise();

        Ok(())
    }

    fn load_noise(&mut self, dir: &Path) {
        let Some(path) = find_noise_file(dir) else {
            return;
        };
        // try to load noise
        self.noise = SoundWrapper::from_path(/*self.system*/ &path).ok();
    }

    pub fn has_sounds(&self) -> bool {
        self.players.0.has_sounds() || self.players.1.has_sounds()
    }

    fn get_random_click(&mut self, typ: ClickType, player2: bool) -> (SoundWrapper, ClickType) {
        if player2 {
            self.players
                .1
                .random_sound(typ)
                .unwrap_or_else(|| self.players.0.random_sound(typ).unwrap())
        } else {
            self.players
                .0
                .random_sound(typ)
                .unwrap_or_else(|| self.players.1.random_sound(typ).unwrap())
        }
    }

    fn maybe_init_kittyaudio(&mut self) {
        if self.conf.use_fmod {
            return;
        }
        log::debug!("starting kittyaudio playback thread");
        self.mixer = Mixer::new();
        let device = self.get_device();

        self.mixer.init_ex(
            device,
            StreamSettings {
                buffer_size: Some(self.conf.buffer_size),
                ..Default::default()
            },
        );
    }

    pub unsafe fn init_fmod(&mut self) -> Result<()> {
        /*
        const SYSTEM_SAMPLERATE: i32 = 48_000;
        log::info!("initializing fmod system");
        if !self.system.is_null() {
            self.release_fmod();
        }

        FMOD_System_Create(&mut self.system, FMOD_VERSION).fmod_result()?;
        let extra_driver_data = FMODAudioEngine::shared().extra_driver_data();

        FMOD_System_SetSoftwareFormat(self.system, SYSTEM_SAMPLERATE, FMOD_SPEAKERMODE_STEREO, 0)
            .fmod_result()?;

        // set buffer size
        /*
        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
            .fmod_result()?;

        let mut numbuffers = 0i32;
        let mut bufferlength = 0u32;
        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
            .fmod_result()?;
        log::info!(
            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
        );
        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
            .fmod_result()?;
        */

        // init system
        self.fmod_apply_buffer_size()?;
        FMOD_System_Init(self.system, 2048, FMOD_INIT_NORMAL, extra_driver_data).fmod_result()?;

        log::info!("successfully initialized fmod system, samplerate: {SYSTEM_SAMPLERATE}");
        */
        Ok(())
    }

    //fn fmod_apply_buffer_size(&self) -> Result<()> {
    //    /*
    //    unsafe {
    //        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
    //            .fmod_result()?;
    //
    //        let mut numbuffers = 0i32;
    //        let mut bufferlength = 0u32;
    //        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
    //            .fmod_result()?;
    //        log::info!(
    //            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
    //        );
    //        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
    //            .fmod_result()?;
    //    }
    //    */
    //    Ok(())
    //}

    pub fn release_fmod(&mut self) {
        /*
        let _ = unsafe {
            FMOD_System_Release(self.system)
                .fmod_result()
                .map_err(|e| log::error!("failed to release fmod system: {e}"))
        };
        self.system = std::ptr::null_mut();
        */
    }

    pub fn init(&mut self) {
        // update thread
        #[cfg(feature = "special")]
        {
            let devices_arc = self.devices.clone();
            std::thread::spawn(move || {
                let mut prev_devices = vec![];
                loop {
                    if unsafe { BOT.conf.use_fmod } {
                        continue;
                    }
                    if let Ok(devices) = kittyaudio::device_names() {
                        // only lock when device lists do not match
                        if devices != prev_devices {
                            log::trace!("updated device list: {devices:?}");
                            *devices_arc.lock().unwrap() = devices.clone();
                            prev_devices = devices;
                        }
                    }
                    std::thread::sleep(Duration::from_secs(4));
                }
            });
        }

        // init audio playback
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }
        unsafe {
            let _ = self
                .init_fmod()
                .map_err(|e| log::error!("failed to init fmod: {e}"));
        };

        // reload clickpacks
        let _ = self
            .reload_clickpacks()
            .map_err(|e| log::error!("failed to reload clickpacks: {e}"));

        // check env
        let toast_queue = self.toast_queue.clone();
        let preload_clickpack = |path: PathBuf| {
            std::thread::spawn(move || {
                Self::load_clickpack_thread(
                    |e| {
                        toast_queue.lock().unwrap().push(Toast {
                            kind: ToastKind::Error,
                            text: format!("Failed to preload clickpack: {e}").into(),
                            options: ToastOptions::default().duration_in_seconds(5.0),
                        })
                    },
                    &path,
                )
            });
        };

        // preload clickpack
        log::info!("preloading clickpack");
        match &self.env.clickpack {
            Clickpack::Name(name) => {
                let mut found = false;
                for path in &self.clickpacks {
                    if path.file_name().unwrap().to_str().unwrap() == name {
                        preload_clickpack(path.clone());
                        found = true;
                        break;
                    }
                }
                if !found {
                    self.toast_queue.lock().unwrap().push(Toast {
                        kind: ToastKind::Error,
                        text: format!("Clickpack \"{name}\" not found").into(),
                        options: ToastOptions::default().duration_in_seconds(3.0),
                    })
                }
            }
            Clickpack::Path(path) => {
                preload_clickpack(path.clone());
            }
            Clickpack::None => log::info!("env.json doesn't specify a clickpack"),
        }

        // init game hooks
        #[cfg(not(feature = "geode"))]
        {
            log::debug!("initializing hooks");
            unsafe { hooks::init_hooks() };
        }
    }

    #[inline]
    fn is_in_level(&self) -> bool {
        #[cfg(feature = "geode")]
        return self.is_in_level;
        #[cfg(not(feature = "geode"))]
        return !self.playlayer.is_null();
    }

    /// Return whether a given [PlayerObject] is player 2. If playlayer is null,
    /// always return false.
    // #[allow(unused_variables, dead_code)]
    #[inline]
    pub fn is_player2_obj(&self, player: *mut c_void /*PlayerObject*/) -> bool {
        #[cfg(not(feature = "geode"))]
        {
            // !self.playlayer.is_null() && self.playlayer.player2() == player
            if !self.is_in_level() {
                return false;
            }
            let player2 = (self.playlayer as usize + 2172) as *const usize;
            return player as usize == unsafe { *player2 };
        }
        #[cfg(feature = "geode")]
        return false;
    }

    // TODO
    pub fn is_2player(&self) -> bool {
        self.conf.force_2player
        // if self.playlayer.is_null() {
        //     return false;
        // }
        // GameManager::shared().level_settings().is_2player()
    }

    fn get_pitch(&self) -> f64 {
        if self.conf.pitch_enabled {
            rand::thread_rng().gen_range(self.conf.pitch.from..=self.conf.pitch.to)
        } else {
            1.0
        }
    }

    pub fn on_init(&mut self) {
        self.prev_time = 0.0;
        self.prev_click_type = ClickType::None;
        self.prev_resolved_click_type = ClickType::None;
        self.prev_pitch = 0.0;
        self.prev_volume = self.conf.volume_settings.global_volume;
        self.prev_spam_offset = 0.0;
        self.level_start = Instant::now();
    }

    pub fn on_reset(&mut self) {
        self.level_start = Instant::now();
    }

    pub unsafe fn on_action(&mut self, push: bool, player2: bool, _button: PlayerButton) {
        // log::info!(
        //     "on action: palyelayer: {:#x}, base: {:#x}",
        //     self.playlayer as usize,
        //     get_base()
        // );
        //log::info!("push: {push}");
        if self.num_sounds == (0, 0) || !self.is_in_level() || !self.conf.enabled {
            return;
        }
        // is_in_level
        if *(self.playlayer as *const bool).offset(0x2f17) || BOT.playlayer_time == 0.0 {
            return;
        }
        // let pl_time = unsafe { *((self.playlayer as usize + 0x328) as *const f64)
        // if unsafe { *((self.playlayer as usize + 0x2f17) as *const bool) } {
        //     return;
        // }

        // if (!self.playlayer.level_settings().is_2player() && player2)
        //     || self.playlayer.is_paused()
        //     || (!push && self.playlayer.time() == 0.0)
        // {
        //     return;
        // }

        // #[cfg(not(feature = "special"))]
        // if self.playlayer.is_dead() {
        //     return;
        // }

        let now = self.time();
        let dt = (now - self.prev_time).abs() as f32;
        let click_type = ClickType::from_time(push, dt, &self.conf.timings);
        let use_fmod = self.conf.use_fmod;

        // get click
        let (mut click, resolved_click_type) = self.get_random_click(click_type, player2);
        let pitch = self.get_pitch() * self.conf.click_speedhack;
        // if self.conf.sync_speed_with_game {
        //     pitch *= gd_audio_pitch() as f64;
        // }
        if !use_fmod {
            click.set_playback_rate(PlaybackRate::Factor(pitch));
        }

        // compute & change volume
        {
            let vol = &self.conf.volume_settings;
            let mut volume = 1.0;
            if vol.volume_var != 0.0 {
                volume += rand::thread_rng().gen_range(-vol.volume_var..=vol.volume_var);
            }

            // calculate spam volume change
            if (!resolved_click_type.is_release() || vol.change_releases_volume)
                && dt < vol.spam_time
                && vol.enabled
            {
                let offset = (vol.spam_time - dt) * vol.spam_vol_offset_factor;
                self.prev_spam_offset = offset;
                volume -= offset.min(vol.max_spam_vol_offset);
            } else {
                self.prev_spam_offset = 0.0;
            }

            // multiply by global volume after all of the changes
            volume *= vol.global_volume;

            if !use_fmod {
                click.set_volume(volume);
            }
            self.prev_volume = volume;
        }

        // stop all playing sounds (acb behaviour)
        if !use_fmod
            && self.conf.cut_sounds
            && (!click_type.is_release() || self.conf.cut_by_releases)
        {
            for sound in &self.mixer.renderer.guard().sounds {
                // check if this is the noise sound, we don't want to stop it
                let sound_len = sound.guard().frames.len();
                if let Some(noise_sound) = &self.noise_sound {
                    if noise_sound.guard().frames.len() == sound_len {
                        continue;
                    }
                }

                // kis!!
                sound.seek_to_end();
            }
        }
        // FIXME: 22 fix
        if !use_fmod || true {
            self.mixer.play(click.sound);
        } else {
            /*
            unsafe {
                FMOD_System_PlaySound(
                    self.system,
                    click.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    &mut self.channel,
                );
                FMOD_Channel_SetPitch(self.channel, pitch as f32);
                FMOD_Channel_SetVolume(self.channel, self.prev_volume);
                FMOD_System_Update(self.system);
            }
            */
        }
        self.prev_time = now;
        self.prev_click_type = click_type;
        self.prev_resolved_click_type = resolved_click_type;
        self.prev_pitch = pitch;
    }

    #[inline]
    fn time(&self) -> f64 {
        if self.conf.use_playlayer_time && self.is_in_level() {
            #[cfg(not(feature = "geode"))]
            return unsafe { *((self.playlayer as usize + 0x328) as *const f64) };
            #[cfg(feature = "geode")]
            return self.playlayer_time;
            // self.playlayer
            //     .to_option()
            //     .map_or_else(|| self.level_start.elapsed().as_secs_f64(), |p| p.time())
        } else {
            self.level_start.elapsed().as_secs_f64()
        }
        // self.level_start.elapsed().as_secs_f64() // TODO
    }

    fn open_clickbot_toggle_toast(&self, toasts: &mut Toasts) {
        toasts.add(Toast {
            kind: ToastKind::Info,
            text: if self.conf.enabled {
                "Enabled clickbot".into()
            } else {
                "Disabled clickbot".into()
            },
            options: ToastOptions::default().duration_in_seconds(2.0),
        });
    }

    fn reload_clickpacks(&mut self) -> Result<()> {
        let path = Path::new(".zcb/clickpacks");
        std::fs::create_dir_all(path)?;
        let dir = path.read_dir()?;
        self.clickpacks.clear();
        for entry in dir {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                self.clickpacks.push(path);
            }
        }
        Ok(())
    }

    pub fn draw_ui(&mut self, ctx: &egui::Context) {
        // process hotkeys
        let wants_keyboard = ctx.wants_keyboard_input();
        let (toggle_menu, toggle_bot, toggle_noise) = ctx.input_mut(|i| {
            // for some reason it deadlocks when i put `ctx.wants_keyboard_input()` here?
            if wants_keyboard {
                (false, false, false)
            } else {
                (
                    self.conf.shortcuts.toggle_menu.pressed(i),
                    self.conf.shortcuts.toggle_bot.pressed(i),
                    self.conf.shortcuts.toggle_noise.pressed(i),
                )
            }
        });
        if toggle_menu {
            self.conf.hidden = !self.conf.hidden;
        }
        if toggle_bot {
            self.conf.enabled = !self.conf.enabled;
        }
        if toggle_noise {
            self.conf.play_noise = !self.conf.play_noise;
            self.play_noise();
        }

        // auto-save config
        if self.last_conf_save.elapsed() > Duration::from_secs(2)
            && self.conf != self.prev_conf
            && !self.did_reset_config
        {
            self.conf.save();
            self.last_conf_save = Instant::now();
            self.prev_conf = self.conf.clone();
        }

        // don't draw/autosave if not open
        if self.conf.hidden {
            return;
        }

        // clickpack reloading
        if self.last_clickpack_reload.elapsed() > Duration::from_secs(3) {
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks: {e}"));
            self.last_clickpack_reload = Instant::now();
        }

        // draw overlay
        let modal = Arc::new(Mutex::new(Modal::new(ctx, "global_modal")));
        let mut toasts = Toasts::new()
            .anchor(Align2::RIGHT_BOTTOM, pos2(-16.0, -16.0))
            .direction(Direction::BottomUp);

        if toggle_bot {
            self.open_clickbot_toggle_toast(&mut toasts);
        }
        if toggle_noise {
            self.open_noise_toggle_toast(&mut toasts);
        }

        // show all queued toasts
        for toast in self.toast_queue.lock().unwrap().drain(..) {
            toasts.add(toast);
        }

        // remove tooltip delay
        ctx.style_mut(|s| s.interaction.tooltip_delay = 0.0);

        egui::Window::new("ZCB Live").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.conf.stage, Stage::Clickpack, "Clickpack");
                ui.selectable_value(&mut self.conf.stage, Stage::Audio, "Audio");
                ui.selectable_value(&mut self.conf.stage, Stage::Options, "Options");
                // ui.selectable_value(&mut self.conf.stage, Stage::Cheats, "Cheats");
            });
            ui.separator();

            egui::ScrollArea::both().show(ui, |ui| {
                match self.conf.stage {
                    Stage::Clickpack => self.show_clickpack_window(ui, modal.clone()),
                    Stage::Audio => {
                        if ui
                            .checkbox(&mut self.conf.enabled, "Enable clickbot")
                            .changed()
                        {
                            self.open_clickbot_toggle_toast(&mut toasts);
                        }

                        // ui.separator();
                        ui.add_enabled_ui(self.conf.enabled, |ui| {
                            self.show_audio_window(ui, &mut toasts);
                        });
                    }
                    Stage::Options => self.show_options_window(ui, modal.clone(), &mut toasts),
                    Stage::Cheats => self.show_cheats_window(ui),
                };
            });
        });

        toasts.show(ctx);
        modal.lock().unwrap().show_dialog();
    }

    fn show_cheats_window(&mut self, ui: &mut egui::Ui) {
        ui.checkbox(&mut self.conf.cheats.noclip, "Noclip");
    }

    pub fn maybe_alloc_console(&self) {
        if self.conf.show_console {
            if unsafe { AllocConsole() }.is_ok() {
                static INIT_ONCE: Once = Once::new();
                INIT_ONCE.call_once(|| {
                    simple_logger::SimpleLogger::new()
                        .init()
                        .expect("failed to initialize simple_logger");
                });
            }
        }
    }

    fn show_options_window(
        &mut self,
        ui: &mut egui::Ui,
        modal: Arc<Mutex<Modal>>,
        toasts: &mut Toasts,
    ) {
        ui.collapsing("Shortcuts", |ui| {
            let mut show_shortcut = |shortcut: &mut Shortcut, id: &'static str, name: &str| {
                ui.horizontal(|ui| {
                    ui.vertical(|ui| ui.add(Keybind::new(shortcut, id).with_text(name)));
                    if *shortcut != Shortcut::NONE {
                        if ui
                            .button("Clear")
                            .on_hover_text("Set the shortcut to none")
                            .clicked()
                        {
                            *shortcut = Shortcut::NONE;
                        }
                    }
                });
            };
            show_shortcut(
                &mut self.conf.shortcuts.toggle_menu,
                "toggle_menu_keybind",
                "Toggle menu",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_bot,
                "toggle_bot_keybind",
                "Toggle bot",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_noise,
                "toggle_noise_keybind",
                "Toggle noise",
            );
        });
        ui.collapsing("Configuration", |ui| {
            ui.horizontal(|ui| {
                help_text(
                    ui,
                    "Use an alternate pushbutton/releasebutton hook for bot compatibility",
                    |ui| {
                        if ui
                            .checkbox(&mut self.conf.use_alternate_hook, "Use alternate hook")
                            .changed()
                        {
                            self.show_alternate_hook_warning = !self.show_alternate_hook_warning;
                            if self.show_alternate_hook_warning {
                                toasts.add(Toast {
                                    kind: ToastKind::Info,
                                    text: "Changing this option requires a game restart!".into(),
                                    options: ToastOptions::default().duration_in_seconds(2.0),
                                });
                            }
                        }
                    },
                );
                if self.show_alternate_hook_warning {
                    ui.label(RichText::new("Requires restart!").color(Color32::YELLOW));
                }
            });
            help_text(
                ui,
                "Use if the Debug tab in Clickbot doesn't appear when you enter a level.\nRequires restart!",
                |ui| ui.checkbox(&mut self.conf.hook_wait, "Wait until hooking"),
            );
            help_text(ui, "Show debug console", |ui| {
                if ui
                    .checkbox(&mut self.conf.show_console, "Show console")
                    .changed()
                {
                    if self.conf.show_console {
                        self.maybe_alloc_console();
                    } else {
                        let _ = unsafe { FreeConsole() };
                    }
                }
            });
            help_text(
                ui,
                "Synchronize actions with the timestep of the game",
                |ui| ui.checkbox(&mut self.conf.use_playlayer_time, "Use PlayLayer time"),
            );
            help_text(
                ui,
                "Use MinHook instead of Retour for hooking",
                |ui| ui.checkbox(&mut self.conf.use_minhook, "Use MinHook"),
            );

            ui.horizontal(|ui| {
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Save")
                    .on_hover_text(
                        "Save the current configuration.\n\
                        This happens automatically, unless you reset your config!",
                    )
                    .clicked()
                {
                    self.conf.save();
                    self.did_reset_config = false;
                    self.prev_conf = self.conf.clone();
                    toasts.add(Toast {
                        kind: ToastKind::Success,
                        text: "Saved configuration to .zcb/config.json".into(),
                        options: ToastOptions::default().duration_in_seconds(2.0),
                    });
                }
                if self.conf != self.prev_conf {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    ui.label("(!)").on_hover_text("Unsaved changes");
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Load")
                    .on_hover_text("Load the config from .zcb/config.json")
                    .clicked()
                {
                    let conf = Config::load();
                    if let Ok(conf) = conf {
                        self.conf = conf;
                        self.apply_config();
                        toasts.add(Toast {
                            kind: ToastKind::Success,
                            text: "Loaded configuration from .zcb/config.json".into(),
                            options: ToastOptions::default().duration_in_seconds(2.0),
                        });
                    } else if let Err(e) = conf {
                        modal
                            .lock()
                            .unwrap()
                            .dialog()
                            .with_title("Failed to load config!")
                            .with_body(utils::capitalize_first_letter(&e.to_string()))
                            .with_icon(Icon::Error)
                            .open();
                    }
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Reset")
                    .on_hover_text("Reset the current configuration to defaults")
                    .clicked()
                {
                    let prev_stage = self.conf.stage;
                    self.conf = Config::default();
                    self.conf.stage = prev_stage; // don't switch current tab
                    self.did_reset_config = true;
                    self.apply_config();
                    toasts.add(Toast {
                        kind: ToastKind::Info,
                        text: "Reset configuration to defaults".into(),
                        options: ToastOptions::default().duration_in_seconds(2.0),
                    });
                }
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .zcb folder")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".zcb")
                        .map_err(|e| log::error!("failed to create .zcb: {e}"));
                    Command::new("explorer").arg(".zcb").spawn().unwrap();
                }
            });
            ui.label(format!(
                "Last saved {:.2?}s ago",
                self.last_conf_save.elapsed().as_secs_f32()
            ));
        });
        ui.allocate_space(ui.available_size() - vec2(0.0, 280.0));
    }

    fn get_device(&mut self) -> Device {
        if !self.env.selected_device.is_empty() && cfg!(feature = "special") {
            Device::from_name(&self.env.selected_device).unwrap_or_default()
        } else {
            log::debug!("using default device");
            self.env.selected_device = Device::Default.name().unwrap_or_default();
            Device::Default
        }
    }

    fn play_noise(&mut self) {
        let stop_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(noise_sound) = noise_sound {
                noise_sound.set_playback_rate(PlaybackRate::Factor(1.0));
                noise_sound.set_loop_enabled(false);
                noise_sound.seek_to_end();
            }
            *noise_sound = None;
        };
        // let stop_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| {
        //     unsafe { FMOD_Channel_Stop(*fmodn) };
        //     *fmodn = std::ptr::null_mut();
        // };
        let mut start_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(mut noise) = self.noise.clone() {
                noise.set_volume(self.conf.noise_volume);
                noise.set_loop_enabled(true);
                let frames = noise.frames.len().saturating_sub(1);
                noise.set_loop_index(0..=frames);
                noise.set_playback_rate(PlaybackRate::Factor(self.conf.noise_speedhack));
                *noise_sound = Some(self.mixer.play(noise.sound));
            }
        };
        /*
        let start_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| unsafe {
            if let Some(noise) = self.noise.clone() {
                // get sound length
                // let mut length = 0u32;
                // FMOD_Sound_GetLength(noise.fmod_sound, &mut length, FMOD_TIMEUNIT_PCM);

                // set loop points for sound
                FMOD_Sound_SetLoopCount(noise.fmod_sound, i32::MAX);
                // FMOD_Sound_SetLoopPoints(
                //     noise.fmod_sound,
                //     0,
                //     FMOD_TIMEUNIT_PCM,
                //     length,
                //     FMOD_TIMEUNIT_PCM,
                // );

                // play the sound
                FMOD_System_PlaySound(
                    self.system,
                    noise.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    fmodn,
                );

                // update channel
                FMOD_Channel_SetVolume(*fmodn, self.conf.noise_volume);
                // FMOD_Channel_SetLoopPoints(*fmodn, 0, FMOD_TIMEUNIT_PCM, 1024, FMOD_TIMEUNIT_PCM);
                FMOD_Channel_SetLoopCount(*fmodn, i32::MAX);
                FMOD_Channel_SetPitch(*fmodn, self.conf.noise_speedhack as f32);
                FMOD_System_Update(self.system);
            }
        };
        */

        stop_kittyaudio_noise(&mut self.noise_sound);
        // stop_fmod_noise(&mut self.fmod_noise_sound);

        if self.conf.use_fmod {
            // if self.conf.play_noise {
            //     start_fmod_noise(&mut self.fmod_noise_sound);
            // } else {
            //     stop_fmod_noise(&mut self.fmod_noise_sound);
            // }
        } else if self.conf.play_noise {
            start_kittyaudio_noise(&mut self.noise_sound);
        } else {
            stop_kittyaudio_noise(&mut self.noise_sound);
        }
    }

    fn open_noise_toggle_toast(&self, toasts: &mut Toasts) {
        toasts.add(Toast {
            kind: ToastKind::Info,
            text: if self.conf.play_noise {
                "Playing noise".into()
            } else {
                "Stopped playing noise".into()
            },
            options: ToastOptions::default().duration_in_seconds(2.0),
        });
    }

    #[cfg(feature = "special")]
    fn show_device_switcher(&mut self, ui: &mut egui::Ui, toasts: &mut Toasts) {
        ui.horizontal(|ui| {
            egui::ComboBox::from_label("Output device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    let devices = self.devices.lock().unwrap().clone();
                    for device in &devices {
                        let is_selected = &self.env.selected_device == device;
                        if ui
                            .selectable_value(&mut self.env.selected_device, device.clone(), device)
                            .clicked()
                            && !is_selected
                        {
                            // start a new mixer on new device
                            log::info!("switching audio device to \"{device}\"");
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                            self.env.save();
                            toasts.add(Toast {
                                kind: ToastKind::Success,
                                text: format!("Switched device to \"{device}\"").into(),
                                options: ToastOptions::default().duration_in_seconds(3.0),
                            });
                        }
                    }
                })
                .response
                .on_disabled_hover_text("Not available with FMOD");
            if ui
                .button("Reset")
                .on_hover_text("Reset to the default audio device")
                .clicked()
            {
                self.mixer = Mixer::new();
                self.mixer.init();
                if let Ok(name) = Device::Default.name() {
                    self.env.selected_device = name.clone();
                    toasts.add(Toast {
                        kind: ToastKind::Success,
                        text: format!("Switched device to \"{name}\"").into(),
                        options: ToastOptions::default().duration_in_seconds(3.0),
                    });
                }
                self.play_noise();
                self.env.save();
                log::debug!("reset audio device");
            }
        });
    }

    fn show_audio_window(&mut self, ui: &mut egui::Ui, toasts: &mut Toasts) {
        ui.add_enabled_ui(self.noise.is_some() && !self.is_loading_clickpack, |ui| {
            ui.horizontal(|ui| {
                if ui
                    .checkbox(&mut self.conf.play_noise, "Play noise")
                    .on_disabled_hover_text("Your clickpack doesn't have a noise file")
                    .on_hover_text("Play the noise file")
                    .changed()
                {
                    self.play_noise();
                    self.open_noise_toggle_toast(toasts);
                }

                if drag_value(
                    ui,
                    &mut self.conf.noise_volume,
                    "Noise volume",
                    0.0..=f32::INFINITY,
                    "",
                )
                .drag_released()
                {
                    self.play_noise(); // restart noise
                }
            });
        });

        /*
        help_text(
            ui,
            "Use the internal audio engine for integration with internal recorders",
            |ui| {
                if ui.checkbox(&mut self.conf.use_fmod, "Use FMOD").changed() {
                    if self.conf.use_fmod {
                        log::info!("destroying kittyaudio mixer");
                        self.mixer = Mixer::new();
                    } else {
                        self.maybe_init_kittyaudio();
                    }
                    self.play_noise();
                }
            },
        );
        */

        help_text(
            ui,
            "Always play 2-player sounds even in regular levels when the player 2 button is pressed",
            |ui| ui.checkbox(&mut self.conf.force_2player, "Force 2-player mode"),
        );

        #[cfg(feature = "special")]
        ui.add_enabled_ui(!self.conf.use_fmod, |ui| {
            self.show_device_switcher(ui, toasts)
        });

        ui.separator();

        ui.collapsing("Timings", |ui| {
            let timings_copy = self.conf.timings.clone();
            let timings = &mut self.conf.timings;
            drag_value(
                ui,
                &mut timings.hard,
                "Hard timing",
                timings_copy.regular..=f32::INFINITY,
                "Anything above this time between clicks plays hardclicks/hardreleases",
            );
            drag_value(
                ui,
                &mut timings.regular,
                "Regular timing",
                timings_copy.soft..=timings_copy.hard,
                "Anything above this time between clicks plays clicks/releases",
            );
            drag_value(
                ui,
                &mut timings.soft,
                "Soft timing",
                0.0..=timings_copy.regular,
                "Anything above this time between clicks plays softclicks/softreleases",
            );
            ui.label(format!(
                "Any value smaller than {:.2?} plays microclicks/microreleases",
                Duration::from_secs_f32(timings.soft),
            ))
        });

        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f32::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f32::INFINITY,
                "Random volume variation (+/-)",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            ui.label("This can be used to lower volume in spams");
            let vol = &mut self.conf.volume_settings;
            help_text(ui, "Apply this logic to releases", |ui| {
                ui.checkbox(&mut vol.change_releases_volume, "Change releases volume")
            });
            drag_value(
                ui,
                &mut vol.spam_time,
                "Spam time",
                0.0..=f32::INFINITY,
                "Time between clicks which are considered spam clicks",
            );
            drag_value(
                ui,
                &mut vol.spam_vol_offset_factor,
                "Spam volume offset factor",
                f32::NEG_INFINITY..=f32::INFINITY,
                "The value which the volume offset factor is multiplied by",
            );
            drag_value(
                ui,
                &mut vol.max_spam_vol_offset,
                "Maximum volume offset",
                f32::NEG_INFINITY..=f32::INFINITY,
                "The maximum value of the volume offset",
            );
        });

        ui.collapsing("Speed", |ui| {
            ui.label("Adjust audio speed/pitch");
            ui.horizontal(|ui| {
                drag_value(
                    ui,
                    &mut self.conf.click_speedhack,
                    "Click speedhack",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for clicks/releases",
                );
                if self.conf.click_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.click_speedhack = 1.0;
                }
            });
            ui.horizontal(|ui| {
                if drag_value(
                    ui,
                    &mut self.conf.noise_speedhack,
                    "Noise speedhack",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for noise. Only useful if your clickpack has a noise file",
                )
                .drag_released()
                {
                    self.play_noise();
                }
                if self.conf.noise_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.noise_speedhack = 1.0;
                    self.play_noise();
                }
            });
            // help_text(ui, "Synchronize click speedhack with game speed", |ui| {
            //     ui.checkbox(&mut self.conf.sync_speed_with_game, "Sync speed with game")
            // });
        });

        ui.collapsing("Advanced", |ui| {
            // let last_bufsize = self.mixer.renderer.guard().last_buffer_size;
            // ui.label(format!("Real buffer size: {last_bufsize}"));

            let prev_bufsize = self.conf.buffer_size;
            help_text(
                ui,
                "Audio buffer size in samples.\nLower value means lower latency",
                |ui| {
                    ui.label("Buffer size");
                },
            );
            if u32_edit_field_min1(ui, &mut self.conf.buffer_size).changed() {
                self.buffer_size_changed = prev_bufsize != self.conf.buffer_size;
            }

            if self.buffer_size_changed {
                ui.horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply buffer size changes")
                        .clicked()
                    {
                        if !self.conf.use_fmod {
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                        } else {
                            self.show_fmod_buffersize_warn = true;
                        }
                        self.buffer_size_changed = false;
                    }

                    if self.conf.buffer_size > 300_000 {
                        ui.label(
                            RichText::new("WARN: Using a high buffer size might cause instability")
                                .color(Color32::YELLOW),
                        );
                    }
                });
            }
            if self.show_fmod_buffersize_warn && self.conf.buffer_size != self.startup_buffer_size {
                ui.label(
                    RichText::new("WARN: Restart the game to apply FMOD buffer size changes")
                        .color(Color32::YELLOW),
                );
            }
            if self.conf.use_fmod && self.startup_buffer_size < 10 {
                ui.label(
                    "If you don't hear any audio, it might be because your buffer size is set too low. \
                    The recommended value for FMOD is 10."
                );
            }
        });

        ui.allocate_space(vec2(100.0, 0.0));
    }

    fn apply_config(&mut self) {
        self.maybe_init_kittyaudio();
        self.play_noise();
    }

    fn load_clickpack_thread(err_fn: impl Fn(anyhow::Error), dir: &Path) {
        unsafe { BOT.is_loading_clickpack = true };
        if let Err(e) = unsafe { BOT.load_clickpack(dir) } {
            log::error!("failed to load clickpack: {e}");
            err_fn(e);
        }
        unsafe { BOT.is_loading_clickpack = false };
    }

    fn select_clickpack_combobox(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let ellipsis = if self.selected_clickpack.len() <= 14 {
            self.selected_clickpack.clone()
        } else {
            format!("{:.14}…", self.selected_clickpack)
        };
        egui::ComboBox::from_label("Select clickpack")
            .selected_text(ellipsis)
            .show_ui(ui, |ui| {
                for path in &self.clickpacks {
                    let dirname = path.file_name().unwrap().to_str().unwrap();
                    if ui
                        .selectable_label(self.selected_clickpack == dirname, dirname)
                        .clicked()
                    {
                        let modal_moved = modal.clone();
                        let path = path.clone();
                        let dirname_moved = dirname.to_string();
                        std::thread::spawn(move || {
                            Self::load_clickpack_thread(
                                |e| {
                                    modal_moved
                                        .lock()
                                        .unwrap()
                                        .dialog()
                                        .with_title("Failed to load clickpack!")
                                        .with_body(utils::capitalize_first_letter(&e.to_string()))
                                        .with_icon(Icon::Error)
                                        .open();
                                },
                                &path,
                            );
                            unsafe { BOT.env.update(Clickpack::Name(dirname_moved)) };
                        });
                    }
                }
            });
    }

    fn select_clickpack_button(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) -> bool {
        if !self.clickpacks.is_empty() {
            self.select_clickpack_combobox(ui, modal);
            return true;
        }
        ui.horizontal(|ui| {
            if ui
                .button("Select clickpack")
                .on_disabled_hover_text("Please wait...")
                .clicked()
            {
                std::thread::spawn(move || {
                    let Some(dir) = FileDialog::new().pick_folder() else {
                        return;
                    };
                    log::debug!("selected clickpack {:?}", dir);
                    Self::load_clickpack_thread(
                        |e| {
                            modal
                                .lock()
                                .unwrap()
                                .dialog()
                                .with_title("Failed to load clickpack!")
                                .with_body(utils::capitalize_first_letter(&e.to_string()))
                                .with_icon(Icon::Error)
                                .open();
                        },
                        &dir,
                    );
                    unsafe {
                        BOT.env.update(Clickpack::Path(dir));
                    }
                });
            }
            if self.num_sounds != (0, 0) {
                ui.label(format!(
                    "Selected clickpack: \"{}\"",
                    self.selected_clickpack
                ));
            } else {
                ui.label("...or put clickpacks in .zcb/clickpacks");
            }
        });
        false
    }

    fn show_clickpack_window(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        if self.is_loading_clickpack {
            ui.horizontal(|ui| {
                ui.label("Loading clickpack...");
                ui.add(egui::Spinner::new());
            });
        }
        let has_sounds = self.num_sounds != (0, 0);

        ui.add_enabled_ui(!self.is_loading_clickpack, |ui| {
            if !self.clickpacks.is_empty() {
                help_text(
                    ui,
                    "If there's no folders inside .zcb/clickpacks,\n\
                    there will be an option to choose the clickpack manually",
                    |ui| {
                        ui.label("Put clickpacks in .zcb/clickpacks");
                    },
                );
            }

            let show_open_folder = |ui: &mut egui::Ui| {
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .zcb/clickpacks")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".zcb/clickpacks")
                        .map_err(|e| log::error!("failed to create .zcb/clickpacks: {e}"));
                    Command::new("explorer")
                        .arg(".zcb\\clickpacks")
                        .spawn()
                        .unwrap();
                }
            };

            let mut is_combobox = false;
            ui.horizontal(|ui| {
                is_combobox = self.select_clickpack_button(ui, modal);
                if !self.selected_clickpack.is_empty() {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    if ui.button("🗙").on_hover_text("Unload clickpack").clicked() {
                        self.unload_clickpack();
                    }
                }
                if is_combobox {
                    show_open_folder(ui);
                }
            });
            if !is_combobox {
                show_open_folder(ui);
            }
        });

        if has_sounds {
            help_text(
                ui,
                if self.num_sounds.1 == 0 {
                    "To add player 2 sounds, make a folder called \"player2\"\n\
                    and put sounds for the second player there"
                } else {
                    "" // will not be shown
                },
                |ui| {
                    ui.label(format!(
                        "{} player 1 sounds, {} player 2 sounds ({} in total)",
                        self.num_sounds.0,
                        self.num_sounds.1,
                        self.num_sounds.0 + self.num_sounds.1
                    ));
                },
            );
        }

        if !self.is_loading_clickpack && has_sounds && self.is_in_level() {
            ui.separator();
            ui.collapsing("Debug", |ui| {
                let dur = Duration::from_secs_f64(self.prev_time);
                let ago = self.time() - dur.as_secs_f64();
                help_text(ui, &format!("{dur:?} since the start of the level"), |ui| {
                    ui.label(format!("Last action time: {dur:.2?} ({ago:.2}s ago)"));
                });
                if self.prev_resolved_click_type != ClickType::None {
                    ui.label(format!(
                        "Last click type: {:?} (resolved to {:?})",
                        self.prev_click_type, self.prev_resolved_click_type
                    ));
                } else {
                    ui.label(format!("Last click type: {:?}", self.prev_click_type));
                }
                ui.label(format!(
                    "Last pitch: {:.4} ({} => {})",
                    self.prev_pitch, self.conf.pitch.from, self.conf.pitch.to
                ));
                ui.label(format!(
                    "Last volume: {:.4} (+/- {} * {})",
                    self.prev_volume,
                    self.conf.volume_settings.volume_var,
                    self.conf.volume_settings.global_volume
                ));
                ui.label(format!(
                    "Last spam volume offset: {:.4}",
                    self.prev_spam_offset
                ));

                let format_path = |path: &Path| {
                    path.to_string_lossy()
                        .replace("\\", "/")
                        .replacen(".zcb/clickpacks/", "", 1)
                };
                let format_path_keep_root = |path: &Path| path.to_string_lossy().replace("\\", "/");

                ui.label(format!(
                    "Last player 1 sound: {:?}",
                    format_path(&self.players.0.last_sound_path)
                ));
                ui.label(format!(
                    "Last player 2 sound: {:?}",
                    format_path(&self.players.1.last_sound_path)
                ));
                ui.label(format!(
                    "Clickpack path: {:?}",
                    format_path_keep_root(&self.selected_clickpack_path)
                ));
                ui.label(format!("Is 2-player level / forced? {}", self.is_2player()));
            });
        }
    }
}

impl Drop for Bot {
    fn drop(&mut self) {
        self.unload_clickpack();
        self.release_fmod()
    }
}
